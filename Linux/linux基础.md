设备文件概念：
以前插入设备驱动代码需要重新编译内核，后来开发人员提出了内核模块的概念。允许将驱动代码插入到运行中的内核而无需重新编译内核。Linux将硬件设备当成特殊的文件--设备文件，设备文件分为以下三类：
- 字符设备文件：处理数据时每次都只能处理一个字符的设备。比如调制解调器，终端
- 块设备文件：处理数据时每次都能处理大块数据的设备，比如硬盘
- 网络设备文件：采用数据包发送和接收数据的设备。例如网卡和一些回环设备

常见的Linux shell：
bash即为Bourne again shell，是由GNU项目开发，被当做标准Unix shell--Bourne shell的替代品

| shell                                                                             | 描述                                                                                        |
| --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| ash                                                                               | 一种运行在内存受限环境中简单的轻量级shell，但是与bash shell完全兼容                         |
| 一种与Bourne shell兼容的编程shell，但支持如关联数组和浮点运算等一些高级的编程特性 | 单元格                                                                                      |
| tcsh                                                                              | 一种将c语言的一些元素引入到shell脚本中的shell                                               |
| zsh                                                                               | 一种结合bash、tcsh和korn的特性，同时提供高级编程特性、共享历史文件和主题化提示符的高级shell |


设置和关闭背景为白色：
```shell
setterm -inversescreen on
setterm -inversescreen off
```

| 选项           | 参数                                            | 描述                                           |
| -------------- | ----------------------------------------------- | ---------------------------------------------- |
| -background    | black,red,green,yellow,blue,magenta,cyan或white | 将终端背景色设置为指定颜色                     |
| -foreground    | black,red,green,yellow,blue,magenta,cyan或white | 将终端前景色设置为指定颜色                     |
| -inversescreen | on或off                                         | 交换背景色和前景色                             |
| -reset         | 无                                              | 将终端外观恢复成默认设置并清屏                 |
| -store         | 无                                              | 将终端当前的前景色和背景色设置成-reset选项的值 |


## 帮助命令
###  man命令
查看bash手册，用于访问存储在Linux系统上的手册页面
![[Pasted image 20220715020818.png]] ^7b8724

命令各个字段描述：

| 节            | 描述                       |
| ------------- | -------------------------- |
| Name          | 显示命令名和一段简短的描述 |
| Synopsis      | 命令的语法                 |
| Configuration | 命令配置信息               |
| Description   | 命令的一般性描述           |
| Options       | 命令选项描述               |
| Exit Status   | 命令退出状态指示           |
| Return Value  | 命令的返回值               |
| Errors        | 命令的错误信息             |
| Environment   | 描述锁使用的环境变量       |
| Files         | 命令用到的文件             |
| Version       | 命令的版本信息             |
| Conforming To | 命令所遵从的标准           |
| Notes         | 其他有帮助的资料           |
| Bugs          | 提供提交Bug的用途          |
| Example       | 展示命令的用法             |
| Authors       | 命令开发人员信息           |
| Copyright     | 命令源代码的版权状况       |
| SeeAlso       | 与该命令类型的其他命令     |

### --help选项
查看帮助文档
### info命令

查看info信息

### type命令

type命令用来显示指定命令的类型。一个命令的类型可以是如下之一
-   alias 别名
-   keyword 关键字，Shell保留字
-   function 函数，Shell函数
-   builtin 内建命令，Shell内建命令
-   file 文件，磁盘文件，外部命令
-   unfound 没有找到

常用选项：

| 选项 | 含义                                                                         |
| ---- | ---------------------------------------------------------------------------- |
| -a   | 可以显示所有可能的类型，比如有些命令如pwd是shell内建命令，也可以是外部命令。 |
| -p   | 只返回外部命令的信息，相当于which命令。 [[linux基础#^e6ca22]]     |
| -f   | 只返回shell函数的信息。                                                      |
| -t   | 只返回指定类型的信息。                                                       |

### which命令

查看命令所在位置
which指令会在环境变量$PATH设置的目录里查找符合条件的文件。

```shell
which [文件...]
```

常用选项：
-   -n<文件名长度> 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
-   -p<文件名长度> 　与-n参数相同，但此处的<文件名长度>包括了文件的路径。
-   -w 　指定输出时栏位的宽度。
-   -V 　显示版本信息。

## Linux文件系统

### Linux目录结构

| 目录  | 用途                                                      |
| ----- | --------------------------------------------------------- |
| /     | 虚拟目录的根目录。通常不会在这里存储文件                  |
| /bin  | 二进制目录，这个目录存放着最经常使用的命令                       |
| /boot | 启动目录，存放启动文件                                    |
| /dev  | 设备目录，Linux在这里创建节点                             |
| /etc  | 系统配置文件目录                                          |
| /home | 主目录，Linux在这里创建用户目录                           |
| /lib  | 库目录，存放系统的应用程序的库文件                        |
| /media |linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。                      |
| /mnt  | 挂在目录，另一个可移动媒体设备的常用挂载点                |
| /opt  | opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。                |
| /proc | 进程目录，存放现有硬件及当前进程的相关信息                |
| /root | root用户的主目录                                          |
| /sbin | 系统二进制目录，存放许多GNU管理员级工具                   |
| /run  | 运行目录，存放系统运作时的运行数据                        |
| /srv  | 服务目录，存放本地服务的相关文件，存放一些服务启动之后需要提取的数据。                     |
| /sys  | 系统目录，存放系统硬件信息的相关文件                      |
| /tmp  | 临时文件目录，/tmp目录会默认清理指定天数未用的文件，系统重启会清空目录。/tmp目录默认清理10天未使用的文件；/var/tmp目录类似，默认清理30天未使用的文件 |
| /var  | 可变目录，可以存放经常变化的文件，比如日志文件            |
| /usr  |  usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。                                                         |


## 监测程序
### 查看进程PS命令
Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数： 
- Unix风格的参数，前面加单破折线； 
- BSD风格的参数，前面不加破折线；
- GNU风格的长参数，前面加双破折线。

![[Pasted image 20220715115544.png]]

Unix风格中，使用-e选项显示所有运行的进程，-f选项扩展输出，一般-ef方式一起使用。输出文本中各列含义：
![[Pasted image 20220715115942.png]]

### 实时检测进程top命令

输出文本各列含义：
![[Pasted image 20220715120550.png]]

默认情况下，top命令在启动时会按照%CPU值对进程排序。可以在top运行时使用多种交互命令重新排序
- 键入f：允 许你选择对输出进行排序的字段
- 键入d：允许你修改轮询间隔
- 键入q：可以退出top。

### 后台进程命令
![[Pasted image 20220715211049.png]]

jobs命令常用选项：

| 选项 | 含义                                 |
| ---- | ------------------------------------ |
| -l   | 列出进程的PID号                      |
| -n   | 只列出上次发出通知后改变了状态的进程 |
| -p   | 只列出进程的PID号                    |
| -r   | 只列出运行中的进程                   |
| -s   | 只列出已停止的进程                    |

### 结束进程
**kill**命令：
通过进程ID（PID）给进程发送一个TERM信号。只能用进程的PID而不能用命令名。要发送进程信号，你必须是进程的属主或登录为root用户，不符管教的进程会自动忽略
**killall**命令：
支持通过进程名而不是PID来结束进程。killall命令也支持通 配符

## 监测磁盘空间
### 挂载命令mount
直接输入mount命令会输出当前系统上挂载的设备列表

![[Pasted image 20220715121607.png]]

手动挂载媒体目录：
```shell
mount -t type device directory
```

type参数指定了磁盘被格式化的文件系统类型，后面两个参数定义了该存储设备的设备文件的位置以及挂载点在虚拟目录中的位置。

### 卸载命令umount
```shell
umount [directory | device ]
```

umount命令支持通过设备文件或者是挂载点来指定要卸载的设备。如果有任何程序正在使
用设备上的文件，系统就不会允许你卸载它

### df命令
df命令可以让你很方便地查看所有已挂载磁盘的使用情况
常用选项-h，它会把输出中的磁盘空间按照用户易读的形式显示，通常用M来替代兆字节，用G替代吉字节
```shell
df -h
```

### du命令
du命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况
常用选项：
- -c：显示所有已列出文件总的大小。 
- -h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字 节。
- -s：显示每个输出参数的总计

## 处理数据文件
### sort排序命令
```shell
sort -h file1
```

常用选项：
![[Pasted image 20220715125732.png]]

### grep命令

[[文本操作三剑客#grep|grep命令]]

```shell
grep [options] pattern [file]
```

常用选项：
- -v：反向搜索
- -n：显示匹配模式的行所在的行号
- -c：输出匹配的总行数
- -e：要指定多个匹配模式

### 数据打包和压缩
目前，Unix和Linux上最广泛使用的归档工具是tar命令。 tar命令最开始是用来将文件写到磁带设备上归档的，然而它也能把输出写到文件里，这种用法在Linux上已经普遍用来归档数据了
```shell
tar function [options] object1 object2 ...
```

常用选项：
![[Pasted image 20220715131408.png]]

1. 使用tar压缩文件夹

**tar -zcvf test.tar.gz ./test/**

该命令表示压缩当前文件夹下的文件夹test，压缩后缀名为test.tar.gz

如果不需要压缩成gz，只需要后缀为tar格式的，那么输入如下命令：

**tar -cvf test.tar ./test/**

2. 使用tar解压文件

**tar -zxvf test.tar.gz**

该命令表示把后缀为.tar.gz的文件解压到当前文件夹下。

如果压缩文件的后缀是.tar，没有gz，则使用命令:

**tar -xvf test.tar**

## 理解shell
### bash命令
用于创建一个子shell
常用选项：
![[Pasted image 20220715204345.png]]

`exit`命令用于退出shell，还能用来登出当前的虚拟控制台终端或终端仿真器软件

使用`()`使命令列表变成了进程列表，生成了一个子shell来执行对应的命令
例如：
```shell
$ pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL
# 环境标量$BASH_SUBSHELL用于输出子所在的子shell编号
```

![[Pasted image 20220715210024.png]]

另一种命令分组是将命令放入花括号中， 并在命令列表尾部加上分号`;`。语法为`{ command; }`（花括号与命令之间要有空格）。使用花括号进行命令分组并不 会像进程列表那样创建出子shell。

### 协程
协程可以同时做两件事。它在后台生成一个子shell，并在这个子shell中执行命令。
格式如下：
```shell
coproc [NAME] command [redirections]

# 给协程命名（协程能够让你尽情发挥想象力，发送或接收来自子shell中进程的信息。
# 只有在拥有多个协 程的时候才需要对协程进行命名，因为你得和它们进行通信。否则
# 的话，让coproc命令 将其设置成默认的名字COPROC就行了）
coproc My_Job { sleep 10; }
```

上述命令用于创建一个名为NAME的协作进程，如果没有指定NAME，则使用默认名称COPROC；当命令command是一个简单的命令时，不能指定NAME，因为这个值可能被当作命令的一部分。当coproc命令执行时，shell在当前进程中创建一个名为NAME的数组变量

### 内建命令和非内建命令
**非内建命令**（外部命令），有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。例如`ps`命令就是外部命令，当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。外部命令`ps`很方便显示出它的父进程以及自己所对应的衍生子进程。当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。外部命令是具有一定代价的
![[Pasted image 20220715214323.png]] ^e6ca22

**内建命令**和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。
#### 内建命令history
- bash shell会跟踪你用过的命令。你可以唤回这些命令并重新使用。
- 命令历史记录被保存在隐藏文件.bash_history中，它位于用户的主目录中
- 输入`!!`，然后按回车键能够唤出刚刚用过的那条命令来使用。或者是使用`!num`任意数字编号换回任意一条历史命令使用
- 修改名为HISTSIZE 的环境变量设置bash历史记录中的命令数

#### 内建命令alias
alias命令是另一个shell的内建命令。命令别名允许你为常用的命令（及其参数）创建另一个名称，从而将输入量减少到最低。
查看当前可用的别名：
```shell
alias -p
```
创建别名：
```shell
alias li='ls -li'
```

## 环境变量

全局变量：对于shell会话和所有生成的子shell都可见
局部变量：局部变量则只对创建它们的shell可见

尽管bash shell使用一致的专有环境变量，但不同的Linux发行版经常会添加其自有的环境变量

### 查看环境变量：
```shell
# 两个命令都能查看所有的环境变量
printenv

env
# 查看单个环境变量
printenv JAVA_HOME

echo $JAVA_HOME
# 显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量 以及用户定义变量。
set
```

### 设置环境变量
```shell
# 设置局部用户定义环境变量(直接使用变量名=值)
my_variable=value

# 设置全局环境变量(先设置一个局部环境变量，然后使用export导入到全局环境中)
# 这种方式创建的环境变量只对当前shell和当前shell的子shell有效
export my_variable=value
```

### 删除环境变量
```shell
# 在子进程中删除环境变量只对子进程有效，父进程中的环境变量仍然存在
unset my_variable
```

### [[环境变量|环境变量持久化]]
#### 登录shell
登入Linux系统启动一个bash shell时，默认情况下bash会在几个文件中查找命令。这些文件叫作启动文件或环境文件。bash检查的启动文件取决于你启动bash shell的方式。启动bash shell有3种方式：
1. 登录时作为默认登录shell
2. 作为非登录shell的交互式shell
3. 作为运行脚本的非交互shell

登录Linux系统时，bash shell作为登录shell启动。登录shell会从5个不同的启动文件里读取命令：
- /etc/profile 
- $HOME/.bash_profile 
- $HOME/.bashrc 
- $HOME/.bash_login 
- $HOME/.profile
`/etc/profile`文件是系统上默认的bash shell的主启动文件。系统上的每个用户登录时都会执行
这个启动文件。另外四个文件是针对用户的。
#### 交互式shell进程
如果你的bash shell不是登录系统时启动的（比如是在命令行提示符下敲入bash时启动），那
么你启动的shell叫作交互式shell
如果bash是作为交互式shell启动的，它就不会访问/etc/profile文件，只会检查用户HOME目录
中的.bashrc文件
#### 非交互式shell进程
系统执行脚本时用的shell为非交互式shell，它没有命令行提示符。但是当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令。为了处理这种情况，bash shell提供了BASH_ENV环境变量。当shell启动一个非交互式shell进程时，它会检查这个环境变量来查看要执行的启动文件。
有些shell脚本是通过启动一个子shell来执行的（参见第5章）。子shell可以继承父shell导出过的变量。
#### 如何持久化环境变量
可以利用各shell对应的环境变量文件创建自己的永久性全局变量或局部变量。

对全局环境变量来说（Linux系统中所有用户都需要使用的变量），可能更倾向于将新的或修 改过的变量设置放在/etc/profile文件中，但这可不是什么好主意。如果你升级了所用的发行版， 这个文件也会跟着更新，那你所有定制过的变量设置可就都没有了。 最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变

量设置放在这个文件中。 在大多数发行版中，存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件。这一点适用于所有类型的shell进程。但如果设置了BASH_ENV变量，那么记住，除非它指向的是 $HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方。

例如alias命令设置是不能持久化的，以把自己的alias设置放在$HOME/.bashrc启动文件中，使其效果永久化。
### 数组环境变量
环境变量可以作为数组使用
```shell
# 定义数组环境变量
mytest=(one two three four five)

# 使用数组环境变量
echo $mytest          #one

echo ${mytest[2]}     #three

echo ${mytest[*]}     #one two three four five
```

## Linux文件权限
### 用户管理

Linux系统使用`/etc/passwd`文件来将用户的登录名匹配到对应的UID值，它包含了一些与用户有关的信息。/etc/shadow文件对Linux系统密码管理提供了更多的控制。只有root用户才能访问/etc/shadow文件，这让它比起/etc/passwd安全许多。

#### 添加用户useradd命令
useradd命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中
```shell
# 查看Linux系统中的默认值
useradd -D

# 创建用户并且在/home目录下创建用户名命名的目录
useradd -m user_name
```
还有如下选项：
![[Pasted image 20220718170357.png]]
可以在-D选项后跟上一个指定的值来更改系统默认的新用户设置
```shell
# 修改用户的默认登录shell为tsch shell
useradd -D -s /bin/tsch
```
![[Pasted image 20220718170709.png]]

**adduser命令：**
adduser是一个perl 脚本，在使用的时候会出现类似人机交互的界面，提供选项让用户填写和选择，这个命令比起useradd来说比较简单

#### 删除用户userdel命令
如果你想从系统中删除用户，userdel可以满足这个需求。默认情况下，`userdel`命令会只删除`/etc/passwd`文件中的用户信息，而不会删除系统中属于该账户的任何文件。 如果加上`-r`参数，userdel会删除用户的HOME目录以及邮件目录。然而，系统上仍可能存
有已删除用户的其他文件
```shell
userdel -r user_name
```

#### 修改用户
修改用户可以用到以下命令：
![[Pasted image 20220718171714.png]]
`usermod`命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数 一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外 一些可能派上用场的选项。
- -l：修改用户账户的登录名。 
- -L：锁定账户，使用户无法登录。 
- -p：修改账户的密码。 
- -U：解除锁定，使用户能够登录。

改变用户密码的一个简便方法就是用`passwd`命令。如果需要为系统中的大量用户修改密码，可以使用`chpasswd`命令。`chpasswd`命令能从标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置
> root@hadoop1:/# passwd myuser
> Enter new UNIX password:
> Retype new UNIX password:
> passwd: password updated successfully

